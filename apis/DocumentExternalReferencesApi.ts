/* tslint:disable */
/* eslint-disable */
/**
 * Claims API
 * API for managing insurance claims and ECF transactions.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ClaimDocumentExternalRef,
  ClaimDocumentExternalRefPatch,
  GetDocumentExternalRefs200Response,
  SourceSystem,
  SyncDirection,
  SyncStatus,
  ValidationErrors,
} from '../models/index';
import {
    ClaimDocumentExternalRefFromJSON,
    ClaimDocumentExternalRefToJSON,
    ClaimDocumentExternalRefPatchFromJSON,
    ClaimDocumentExternalRefPatchToJSON,
    GetDocumentExternalRefs200ResponseFromJSON,
    GetDocumentExternalRefs200ResponseToJSON,
    SourceSystemFromJSON,
    SourceSystemToJSON,
    SyncDirectionFromJSON,
    SyncDirectionToJSON,
    SyncStatusFromJSON,
    SyncStatusToJSON,
    ValidationErrorsFromJSON,
    ValidationErrorsToJSON,
} from '../models/index';

export interface DocumentExternalReferencesApiCreateDocumentExternalRefRequest {
    documentID: string;
    claimDocumentExternalRef: ClaimDocumentExternalRef;
}

export interface DocumentExternalReferencesApiDeleteExternalRefRequest {
    id: string;
}

export interface DocumentExternalReferencesApiGetDocumentExternalRefsRequest {
    documentID: string;
    cursor?: string;
    limit?: number;
    includeTotal?: boolean;
    sourceSystem?: SourceSystem;
    externalVersion?: string;
    syncStatus?: SyncStatus;
}

export interface DocumentExternalReferencesApiGetExternalRefRequest {
    id: string;
}

export interface DocumentExternalReferencesApiGetPendingSyncExternalRefsRequest {
    sourceSystem: SourceSystem;
    syncDirection: SyncDirection;
    limit?: number;
}

export interface DocumentExternalReferencesApiQueryExternalRefsRequest {
    claimDocumentId?: string;
    sourceSystem?: SourceSystem;
    transactionId?: string;
    transactionReference?: string;
    externalDocumentId?: string;
    externalDocumentType?: string;
    externalVersion?: string;
    syncStatus?: SyncStatus;
    syncDirection?: SyncDirection;
    cursor?: string;
    limit?: number;
    includeTotal?: boolean;
}

export interface DocumentExternalReferencesApiUpdateExternalRefRequest {
    id: string;
    claimDocumentExternalRefPatch: ClaimDocumentExternalRefPatch;
}

/**
 * 
 */
export class DocumentExternalReferencesApi extends runtime.BaseAPI {

    /**
     * Create a new external reference for a specific document
     * Create a Document External Reference
     */
    async createDocumentExternalRefRaw(requestParameters: DocumentExternalReferencesApiCreateDocumentExternalRefRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ClaimDocumentExternalRef>> {
        if (requestParameters['documentID'] == null) {
            throw new runtime.RequiredError(
                'documentID',
                'Required parameter "documentID" was null or undefined when calling createDocumentExternalRef().'
            );
        }

        if (requestParameters['claimDocumentExternalRef'] == null) {
            throw new runtime.RequiredError(
                'claimDocumentExternalRef',
                'Required parameter "claimDocumentExternalRef" was null or undefined when calling createDocumentExternalRef().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("jwt-authorizer-oauth", []);
        }

        const response = await this.request({
            path: `/claims/documents/{documentID}/external-refs`.replace(`{${"documentID"}}`, encodeURIComponent(String(requestParameters['documentID']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ClaimDocumentExternalRefToJSON(requestParameters['claimDocumentExternalRef']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ClaimDocumentExternalRefFromJSON(jsonValue));
    }

    /**
     * Create a new external reference for a specific document
     * Create a Document External Reference
     */
    async createDocumentExternalRef(requestParameters: DocumentExternalReferencesApiCreateDocumentExternalRefRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ClaimDocumentExternalRef> {
        const response = await this.createDocumentExternalRefRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete an external reference
     * Delete a Document External Reference
     */
    async deleteExternalRefRaw(requestParameters: DocumentExternalReferencesApiDeleteExternalRefRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling deleteExternalRef().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("jwt-authorizer-oauth", []);
        }

        const response = await this.request({
            path: `/claims/documents/external-refs/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete an external reference
     * Delete a Document External Reference
     */
    async deleteExternalRef(requestParameters: DocumentExternalReferencesApiDeleteExternalRefRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteExternalRefRaw(requestParameters, initOverrides);
    }

    /**
     * Get all external references for a specific document
     * Get Document External References
     */
    async getDocumentExternalRefsRaw(requestParameters: DocumentExternalReferencesApiGetDocumentExternalRefsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetDocumentExternalRefs200Response>> {
        if (requestParameters['documentID'] == null) {
            throw new runtime.RequiredError(
                'documentID',
                'Required parameter "documentID" was null or undefined when calling getDocumentExternalRefs().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cursor'] != null) {
            queryParameters['cursor'] = requestParameters['cursor'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['includeTotal'] != null) {
            queryParameters['include_total'] = requestParameters['includeTotal'];
        }

        if (requestParameters['sourceSystem'] != null) {
            queryParameters['source_system'] = requestParameters['sourceSystem'];
        }

        if (requestParameters['externalVersion'] != null) {
            queryParameters['external_version'] = requestParameters['externalVersion'];
        }

        if (requestParameters['syncStatus'] != null) {
            queryParameters['sync_status'] = requestParameters['syncStatus'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("jwt-authorizer-oauth", []);
        }

        const response = await this.request({
            path: `/claims/documents/{documentID}/external-refs`.replace(`{${"documentID"}}`, encodeURIComponent(String(requestParameters['documentID']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetDocumentExternalRefs200ResponseFromJSON(jsonValue));
    }

    /**
     * Get all external references for a specific document
     * Get Document External References
     */
    async getDocumentExternalRefs(requestParameters: DocumentExternalReferencesApiGetDocumentExternalRefsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetDocumentExternalRefs200Response> {
        const response = await this.getDocumentExternalRefsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a specific external reference by ID
     * Get a Document External Reference
     */
    async getExternalRefRaw(requestParameters: DocumentExternalReferencesApiGetExternalRefRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ClaimDocumentExternalRef>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getExternalRef().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("jwt-authorizer-oauth", []);
        }

        const response = await this.request({
            path: `/claims/documents/external-refs/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ClaimDocumentExternalRefFromJSON(jsonValue));
    }

    /**
     * Get a specific external reference by ID
     * Get a Document External Reference
     */
    async getExternalRef(requestParameters: DocumentExternalReferencesApiGetExternalRefRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ClaimDocumentExternalRef> {
        const response = await this.getExternalRefRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get external references that are pending synchronization
     * Get Pending Sync External References
     */
    async getPendingSyncExternalRefsRaw(requestParameters: DocumentExternalReferencesApiGetPendingSyncExternalRefsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ClaimDocumentExternalRef>>> {
        if (requestParameters['sourceSystem'] == null) {
            throw new runtime.RequiredError(
                'sourceSystem',
                'Required parameter "sourceSystem" was null or undefined when calling getPendingSyncExternalRefs().'
            );
        }

        if (requestParameters['syncDirection'] == null) {
            throw new runtime.RequiredError(
                'syncDirection',
                'Required parameter "syncDirection" was null or undefined when calling getPendingSyncExternalRefs().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['sourceSystem'] != null) {
            queryParameters['source_system'] = requestParameters['sourceSystem'];
        }

        if (requestParameters['syncDirection'] != null) {
            queryParameters['sync_direction'] = requestParameters['syncDirection'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("jwt-authorizer-oauth", []);
        }

        const response = await this.request({
            path: `/claims/documents/external-refs/pending-sync`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ClaimDocumentExternalRefFromJSON));
    }

    /**
     * Get external references that are pending synchronization
     * Get Pending Sync External References
     */
    async getPendingSyncExternalRefs(requestParameters: DocumentExternalReferencesApiGetPendingSyncExternalRefsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ClaimDocumentExternalRef>> {
        const response = await this.getPendingSyncExternalRefsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Query all external references with flexible filtering
     * Query External References
     */
    async queryExternalRefsRaw(requestParameters: DocumentExternalReferencesApiQueryExternalRefsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetDocumentExternalRefs200Response>> {
        const queryParameters: any = {};

        if (requestParameters['claimDocumentId'] != null) {
            queryParameters['claim_document_id'] = requestParameters['claimDocumentId'];
        }

        if (requestParameters['sourceSystem'] != null) {
            queryParameters['source_system'] = requestParameters['sourceSystem'];
        }

        if (requestParameters['transactionId'] != null) {
            queryParameters['transaction_id'] = requestParameters['transactionId'];
        }

        if (requestParameters['transactionReference'] != null) {
            queryParameters['transaction_reference'] = requestParameters['transactionReference'];
        }

        if (requestParameters['externalDocumentId'] != null) {
            queryParameters['external_document_id'] = requestParameters['externalDocumentId'];
        }

        if (requestParameters['externalDocumentType'] != null) {
            queryParameters['external_document_type'] = requestParameters['externalDocumentType'];
        }

        if (requestParameters['externalVersion'] != null) {
            queryParameters['external_version'] = requestParameters['externalVersion'];
        }

        if (requestParameters['syncStatus'] != null) {
            queryParameters['sync_status'] = requestParameters['syncStatus'];
        }

        if (requestParameters['syncDirection'] != null) {
            queryParameters['sync_direction'] = requestParameters['syncDirection'];
        }

        if (requestParameters['cursor'] != null) {
            queryParameters['cursor'] = requestParameters['cursor'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['includeTotal'] != null) {
            queryParameters['include_total'] = requestParameters['includeTotal'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("jwt-authorizer-oauth", []);
        }

        const response = await this.request({
            path: `/claims/documents/external-refs`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetDocumentExternalRefs200ResponseFromJSON(jsonValue));
    }

    /**
     * Query all external references with flexible filtering
     * Query External References
     */
    async queryExternalRefs(requestParameters: DocumentExternalReferencesApiQueryExternalRefsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetDocumentExternalRefs200Response> {
        const response = await this.queryExternalRefsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update an external reference
     * Update a Document External Reference
     */
    async updateExternalRefRaw(requestParameters: DocumentExternalReferencesApiUpdateExternalRefRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ClaimDocumentExternalRef>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling updateExternalRef().'
            );
        }

        if (requestParameters['claimDocumentExternalRefPatch'] == null) {
            throw new runtime.RequiredError(
                'claimDocumentExternalRefPatch',
                'Required parameter "claimDocumentExternalRefPatch" was null or undefined when calling updateExternalRef().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("jwt-authorizer-oauth", []);
        }

        const response = await this.request({
            path: `/claims/documents/external-refs/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: ClaimDocumentExternalRefPatchToJSON(requestParameters['claimDocumentExternalRefPatch']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ClaimDocumentExternalRefFromJSON(jsonValue));
    }

    /**
     * Update an external reference
     * Update a Document External Reference
     */
    async updateExternalRef(requestParameters: DocumentExternalReferencesApiUpdateExternalRefRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ClaimDocumentExternalRef> {
        const response = await this.updateExternalRefRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
